@{
    ViewData["Title"] = "Map View";
}

<link rel="stylesheet" href="~/lib/leaflet/leaflet.css" />
<script src="~/lib/leaflet/leaflet.js"></script>

<style>
    body { margin: 0; padding: 0; overflow: hidden; }
    #map-container { position: fixed; top: 64px; right: 320px; bottom: 0; left: 0; }
    #map { height: 100%; width: 100%; }
    .map-sidebar { position: fixed; top: 64px; right: 0; bottom: 0; width: 320px; background: white; overflow-y: auto; padding: 20px; box-shadow: -2px 0 10px rgba(0,0,0,0.1); }
    .loading-overlay { position: fixed; top: 64px; left: 0; right: 0; bottom: 0; background: rgba(255, 255, 255, 0.95); display: flex; flex-direction: column; align-items: center; justify-content: center; z-index: 9999; }
    .spinner { width: 50px; height: 50px; border: 4px solid #e5e7eb; border-top-color: #667eea; border-radius: 50%; animation: spin 0.8s linear infinite; }
    @@keyframes spin { to { transform: rotate(360deg); } }
    .stats-panel { background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); color: white; padding: 20px; border-radius: 12px; margin-bottom: 20px; }
    .stat-item { display: flex; justify-content: space-between; margin: 10px 0; }
    .stat-value { font-weight: bold; font-size: 20px; }
    .search-box { margin-bottom: 20px; }
    .search-input { width: 100%; padding: 12px; border: 2px solid #e5e7eb; border-radius: 8px; font-size: 14px; }
    .search-input:focus { outline: none; border-color: #667eea; }
    .filter-section { margin-bottom: 20px; background: #f9fafb; padding: 15px; border-radius: 8px; }
    .filter-section h3 { margin: 0 0 12px 0; font-size: 16px; color: #374151; }
    .filter-option { display: flex; align-items: center; margin: 8px 0; }
    .filter-option input[type="checkbox"] { margin-right: 8px; width: 18px; height: 18px; cursor: pointer; }
    .filter-option label { cursor: pointer; font-size: 14px; color: #4b5563; flex: 1; }
    .color-indicator { width: 16px; height: 16px; border-radius: 50%; margin-left: 8px; }
    .color-green { background-color: #10b981; }
    .color-yellow { background-color: #f59e0b; }
    .color-red { background-color: #ef4444; }
    .reset-btn { width: 100%; padding: 12px; background: #6b7280; color: white; border: none; border-radius: 8px; cursor: pointer; font-weight: 600; transition: background 0.2s; }
    .reset-btn:hover { background: #4b5563; }
    @@media (max-width: 968px) {
        #map-container { right: 0; bottom: 50%; }
        .map-sidebar { top: auto; bottom: 0; width: 100%; height: 50%; }
    }
    @@media (max-width: 640px) {
        .map-sidebar { height: 60%; }
    }
</style>

<div id="loading-overlay" class="loading-overlay">
    <div class="spinner"></div>
    <p style="color: #6b7280; font-weight: 500;">Loading obstacles...</p>
</div>

<div id="map-container">
    <div id="map"></div>
</div>

<div class="map-sidebar">
    <h2 style="font-size: 24px; font-weight: bold; color: #1f2937; margin-bottom: 20px;">
        üó∫Ô∏è Obstacle Map View
    </h2>

    <div class="stats-panel">
        <h3 style="margin: 0 0 15px 0; font-size: 18px;">üìä Statistics</h3>
        <div class="stat-item">
            <span>Total Obstacles:</span>
            <span class="stat-value" id="stat-total">0</span>
        </div>
        <div class="stat-item">
            <span>‚úÖ Approved:</span>
            <span class="stat-value" id="stat-approved">0</span>
        </div>
        <div class="stat-item">
            <span>‚è≥ Pending:</span>
            <span class="stat-value" id="stat-pending">0</span>
        </div>
        <div class="stat-item">
            <span>‚ùå Rejected:</span>
            <span class="stat-value" id="stat-rejected">0</span>
        </div>
    </div>

    <div class="search-box">
        <input type="text" id="search-input" class="search-input" placeholder="üîç Search by obstacle name..." />
    </div>

    <div class="filter-section" id="type-filter-section">
        <h3>üèóÔ∏è Filter by Type</h3>
        <div class="filter-option">
            <input type="checkbox" id="filter-type-all" checked>
            <label for="filter-type-all">All Types</label>
        </div>
        <!-- Dynamiske type-filtre legges til her av JavaScript -->
    </div>

    <div class="filter-section">
        <h3>üìã Filter by Status</h3>
        <div class="filter-option">
            <input type="checkbox" id="filter-status-approved" checked>
            <label for="filter-status-approved">Approved</label>
            <span class="color-indicator color-green"></span>
        </div>
        <div class="filter-option">
            <input type="checkbox" id="filter-status-pending" checked>
            <label for="filter-status-pending">Pending</label>
            <span class="color-indicator color-yellow"></span>
        </div>
        <div class="filter-option">
            <input type="checkbox" id="filter-status-rejected" checked>
            <label for="filter-status-rejected">Rejected</label>
            <span class="color-indicator color-red"></span>
        </div>
    </div>

    <button class="reset-btn" onclick="resetFilters()">
        üîÑ Reset All Filters
    </button>

    <a asp-action="RegisterforerDashboard" style="display: block; margin-top: 15px; text-align: center; color: #667eea; text-decoration: none; font-weight: 500;">
        ‚Üê Back to Dashboard
    </a>
</div>

@section Scripts {
    <script>
        let map;
        let allObstacles = [];
        let markersLayer;
        let searchTimeout;
        let availableTypes = [];

        document.addEventListener('DOMContentLoaded', function() {
            console.log('üó∫Ô∏è Initialiserer Map View...');
            initializeMap();
            loadObstacles();
            setupInitialEventListeners();
        });

        function initializeMap() {
            map = L.map('map').setView([60.4720, 8.4689], 6);
            L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
                attribution: '&copy; OpenStreetMap contributors',
                maxZoom: 19
            }).addTo(map);
            markersLayer = L.layerGroup().addTo(map);
            console.log('‚úÖ Kart initialisert');
        }

        async function loadObstacles() {
            try {
                console.log('üì° Henter obstacles...');
                const response = await fetch('@Url.Action("GetObstaclesForMapView", "Registerforer")');
                
                if (!response.ok) {
                    throw new Error(`HTTP error! status: ${response.status}`);
                }
                
                const data = await response.json();
                console.log('‚úÖ Data mottatt:', data);
                
                allObstacles = data.obstacles;
                updateStatistics(data.stats);
                buildTypeFilters();
                displayObstacles(allObstacles);
                
                document.getElementById('loading-overlay').style.display = 'none';
                console.log(`üìç ${allObstacles.length} obstacles lastet!`);
            } catch (error) {
                console.error('‚ùå Feil ved lasting av obstacles:', error);
                document.getElementById('loading-overlay').innerHTML = 
                    `<div style="text-align: center; color: #ef4444;">
                        <h3>‚ö†Ô∏è Failed to load obstacles</h3>
                        <p>${error.message}</p>
                        <button onclick="location.reload()" style="margin-top: 20px; padding: 10px 20px; background: #667eea; color: white; border: none; border-radius: 8px; cursor: pointer;">
                            üîÑ Retry
                        </button>
                    </div>`;
            }
        }

        function updateStatistics(stats) {
            document.getElementById('stat-total').textContent = stats.total;
            document.getElementById('stat-approved').textContent = stats.approved;
            document.getElementById('stat-pending').textContent = stats.pending;
            document.getElementById('stat-rejected').textContent = stats.rejected;
        }

        function buildTypeFilters() {
            availableTypes = [...new Set(allObstacles.map(o => o.type))].sort();
            console.log('üèóÔ∏è Tilgjengelige typer:', availableTypes);
            
            const typeFilterSection = document.getElementById('type-filter-section');
            const existingCheckboxes = typeFilterSection.querySelectorAll('.type-checkbox');
            existingCheckboxes.forEach(cb => cb.parentElement.remove());
            
            availableTypes.forEach((type, index) => {
                const div = document.createElement('div');
                div.className = 'filter-option';
                
                const checkbox = document.createElement('input');
                checkbox.type = 'checkbox';
                checkbox.id = `filter-type-${index}`;
                checkbox.className = 'type-checkbox';
                checkbox.dataset.type = type;
                checkbox.addEventListener('change', handleTypeFilterChange);
                
                const label = document.createElement('label');
                label.htmlFor = `filter-type-${index}`;
                label.textContent = type;
                
                div.appendChild(checkbox);
                div.appendChild(label);
                typeFilterSection.appendChild(div);
            });
            
            console.log(`‚úÖ Bygget ${availableTypes.length} type-filtre`);
        }

        function displayObstacles(obstacles) {
            markersLayer.clearLayers();
            console.log(`üé® Viser ${obstacles.length} markers...`);
            
            obstacles.forEach(obstacle => {
                try {
                    // Parse WKT geometry (ikke JSON!)
                    const geometryWKT = obstacle.geometry;
                    
                    if (!geometryWKT) {
                        console.warn(`‚ö†Ô∏è Obstacle ${obstacle.id} har ingen geometry`);
                        return;
                    }

                    let markerColor = '#6b7280';
                    let statusText = 'Unknown';
                    
                    if (obstacle.isApproved) {
                        markerColor = '#10b981';
                        statusText = 'Approved';
                    } else if (obstacle.isPending) {
                        markerColor = '#f59e0b';
                        statusText = 'Pending';
                    } else if (obstacle.isRejected) {
                        markerColor = '#ef4444';
                        statusText = 'Rejected';
                    }
                    
                    const icon = L.divIcon({
                        html: `<div style="background-color: ${markerColor}; width: 24px; height: 24px; border-radius: 50%; border: 3px solid white; box-shadow: 0 2px 4px rgba(0,0,0,0.3);"></div>`,
                        iconSize: [24, 24],
                        className: ''
                    });
                    
                    // Parse WKT basert p√• type
                    if (geometryWKT.startsWith('POINT')) {
                        const coords = geometryWKT.replace('POINT(', '').replace(')', '').split(' ');
                        const lat = parseFloat(coords[1]);
                        const lng = parseFloat(coords[0]);
                        
                        const marker = L.marker([lat, lng], { icon: icon }).addTo(markersLayer);
                        
                        const popupContent = `
                            <div style="min-width: 200px;">
                                <h3 style="margin: 0 0 10px 0; color: #1f2937; font-size: 16px;">${obstacle.name}</h3>
                                <p style="margin: 5px 0;"><strong>Type:</strong> ${obstacle.type}</p>
                                <p style="margin: 5px 0;"><strong>Height:</strong> ${obstacle.height}m</p>
                                <p style="margin: 5px 0;"><strong>Status:</strong> <span style="color: ${markerColor}; font-weight: bold;">${statusText}</span></p>
                                <p style="margin: 5px 0;"><strong>Registered by:</strong> ${obstacle.registeredBy}</p>
                                ${obstacle.description ? `<p style="margin: 10px 0 0 0; font-size: 13px; color: #6b7280;">${obstacle.description}</p>` : ''}
                                <a href="@Url.Action("ViewObstacle", "Registerforer")?id=${obstacle.id}" 
                                   style="display: inline-block; margin-top: 10px; padding: 6px 12px; background: #667eea; color: white; text-decoration: none; border-radius: 6px; font-size: 13px;">
                                    View Details ‚Üí
                                </a>
                            </div>
                        `;
                        
                        marker.bindPopup(popupContent);
                        
                    } else if (geometryWKT.startsWith('LINESTRING')) {
                        const coordsStr = geometryWKT.replace('LINESTRING(', '').replace(')', '');
                        const coordPairs = coordsStr.split(',');
                        const latlngs = coordPairs.map(pair => {
                            const coords = pair.trim().split(' ');
                            return [parseFloat(coords[1]), parseFloat(coords[0])];
                        });
                        
                        const polyline = L.polyline(latlngs, { color: markerColor, weight: 4 }).addTo(markersLayer);
                        
                        const popupContent = `
                            <div>
                                <h3 style="margin: 0 0 10px 0;">${obstacle.name}</h3>
                                <p><strong>Type:</strong> ${obstacle.type}</p>
                                <p><strong>Status:</strong> <span style="color: ${markerColor};">${statusText}</span></p>
                                <a href="@Url.Action("ViewObstacle", "Registerforer")?id=${obstacle.id}">View Details</a>
                            </div>
                        `;
                        
                        polyline.bindPopup(popupContent);
                        
                    } else if (geometryWKT.startsWith('POLYGON')) {
                        const coordsStr = geometryWKT.replace('POLYGON((', '').replace('))', '');
                        const coordPairs = coordsStr.split(',');
                        const latlngs = coordPairs.map(pair => {
                            const coords = pair.trim().split(' ');
                            return [parseFloat(coords[1]), parseFloat(coords[0])];
                        });
                        
                        const polygon = L.polygon(latlngs, { color: markerColor, fillColor: markerColor, fillOpacity: 0.3 }).addTo(markersLayer);
                        
                        const popupContent = `
                            <div>
                                <h3 style="margin: 0 0 10px 0;">${obstacle.name}</h3>
                                <p><strong>Type:</strong> ${obstacle.type}</p>
                                <p><strong>Status:</strong> <span style="color: ${markerColor};">${statusText}</span></p>
                                <a href="@Url.Action("ViewObstacle", "Registerforer")?id=${obstacle.id}">View Details</a>
                            </div>
                        `;
                        
                        polygon.bindPopup(popupContent);
                    }
                } catch (error) {
                    console.error(`‚ùå Feil ved tegning av obstacle ${obstacle.id}:`, error);
                }
            });
            
            console.log(`‚úÖ ${obstacles.length} markers tegnet!`);
        }

        function setupInitialEventListeners() {
            const searchInput = document.getElementById('search-input');
            searchInput.addEventListener('input', function() {
                clearTimeout(searchTimeout);
                searchTimeout = setTimeout(applyFilters, 300);
            });
            
            document.getElementById('filter-type-all').addEventListener('change', function() {
                if (this.checked) {
                    document.querySelectorAll('.type-checkbox').forEach(cb => cb.checked = false);
                }
                applyFilters();
            });
            
            document.getElementById('filter-status-approved').addEventListener('change', applyFilters);
            document.getElementById('filter-status-pending').addEventListener('change', applyFilters);
            document.getElementById('filter-status-rejected').addEventListener('change', applyFilters);
        }

        function handleTypeFilterChange(event) {
            if (event.target.checked) {
                document.getElementById('filter-type-all').checked = false;
            }
            
            const anyTypeChecked = document.querySelectorAll('.type-checkbox:checked').length > 0;
            if (!anyTypeChecked) {
                document.getElementById('filter-type-all').checked = true;
            }
            
            applyFilters();
        }

        function applyFilters() {
            const searchText = document.getElementById('search-input').value.toLowerCase();
            const allTypesChecked = document.getElementById('filter-type-all').checked;
            
            const selectedTypes = [];
            if (!allTypesChecked) {
                document.querySelectorAll('.type-checkbox:checked').forEach(cb => {
                    selectedTypes.push(cb.dataset.type);
                });
            }
            
            const showApproved = document.getElementById('filter-status-approved').checked;
            const showPending = document.getElementById('filter-status-pending').checked;
            const showRejected = document.getElementById('filter-status-rejected').checked;
            
            const filteredObstacles = allObstacles.filter(obstacle => {
                if (searchText && !obstacle.name.toLowerCase().includes(searchText)) return false;
                if (!allTypesChecked && selectedTypes.length > 0 && !selectedTypes.includes(obstacle.type)) return false;
                
                let matchesStatus = false;
                if (obstacle.isApproved && showApproved) matchesStatus = true;
                if (obstacle.isPending && showPending) matchesStatus = true;
                if (obstacle.isRejected && showRejected) matchesStatus = true;
                if (!matchesStatus) return false;
                
                return true;
            });
            
            console.log(`üîç Viser ${filteredObstacles.length} av ${allObstacles.length}`);
            displayObstacles(filteredObstacles);
        }

        function resetFilters() {
            document.getElementById('search-input').value = '';
            document.getElementById('filter-type-all').checked = true;
            document.querySelectorAll('.type-checkbox').forEach(cb => cb.checked = false);
            document.getElementById('filter-status-approved').checked = true;
            document.getElementById('filter-status-pending').checked = true;
            document.getElementById('filter-status-rejected').checked = true;
            displayObstacles(allObstacles);
        }
    </script>
}
